# vim: syntax=sh tabstop=4
#
# This file contains Cbench common support for the bash based
# job scripts used

#
# Some common routines that Cbench job scripts use to help deal
# with where stdout and stderr output is captured
cbench_run_cmd()
{
	local cmd=$@

	# add stdin file to command line if required
	if [ -n "$STDIN_FILE" ] ; then
		local finalcmd="$cmd < $STDIN_FILE"
	else
		local finalcmd="$cmd"
	fi

	# echo out the command-line we'll exec for posterity
	cbench_echo "Cbench joblaunch cmd line: $finalcmd"

	# the simple batch mode case, we don't worry about catching any output
    if [ "$CBENCH_RUN_TYPE" == "BATCH" ]; then
	    $finalcmd
		return
	fi

	# the interactive mode case with echoing of the output requested
    if [ "$CBENCH_RUN_TYPE" == "INTERACTIVE" -a "$CBENCH_ECHO_OUTPUT" == "YES" ]; then
	    $finalcmd 2>&1 | tee -a $STDOUT_FILE 
		return
	fi

	# the simple interactive mode case with just catching the output to file
    if [ "$CBENCH_RUN_TYPE" == "INTERACTIVE" -a -z "$CBENCH_ECHO_OUTPUT" ]; then
	    $finalcmd >> $STDOUT_FILE 2>&1
	fi
}

cbench_echo()
{
	local string=$@

 	# the simple batch mode case, we don't worry about catching any output
    if [ "$CBENCH_RUN_TYPE" == "BATCH" ]; then
	    echo $string
		return
	fi

   	# the interactive mode case with echoing of the output requested
    if [ "$CBENCH_RUN_TYPE" == "INTERACTIVE" -a "$CBENCH_ECHO_OUTPUT" == "YES" ]; then
	    echo $string 2>&1 | tee -a $STDOUT_FILE 
		return
	fi

	# the simple interactive mode case with just catching the output to file
    if [ "$CBENCH_RUN_TYPE" == "INTERACTIVE" -a -z "$CBENCH_ECHO_OUTPUT" ]; then
	    echo $string >> $STDOUT_FILE 2>&1
	fi
}

