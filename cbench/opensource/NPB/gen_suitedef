#!/usr/bin/perl

use Getopt::Long;

GetOptions(
	'maxprocs=i' => \$maxprocs,
	'nasdir=s' => \$nasdir,
	'serial' => \$serial,
);

# Script to generate the NAS suite.def file 

# need to know where everything cbench lives!
$BENCH_HOME = $ENV{CBENCHOME} ? $ENV{CBENCHOME} :
    "$ENV{HOME}\/cbench";

unshift @INC, "$BENCH_HOME";
require "cbench.pl";

# The list of NAS codes to build. The IS (integer sort) and 
# EP (embarrasingly parallel) benchmarks are really not workloads
# we care about.
@codes = qw/ cg ft sp bt mg lu /;

# The list of NAS code classes (which correspond to how much memory
# a NAS code uses and how much work is done) to generate.
# class A and W are too small for us to really care about
@classes = ('B', 'C', 'D');
$suitedef = "$nasdir/config/suite.def";

open (OUT,">$suitedef") or die
	"Could not write $suitedef ($!)";
print OUT "# auto-generated by Cbench make system\n";

if (defined $serial) {
	push @codes, qw/ ep is lu-hp dc ua /;
	for $code (@codes) {
		for $class (@classes) {
			print OUT "$code\t$class\n";
		}
	}
}
else {
	#push @codes, qw/ dt /;
	# loop over all run_sizes in cluster.def
	for $nprocs (@run_sizes) {
		(defined $maxprocs and $nprocs > $maxprocs) and next;
		($nprocs > $max_procs) and next;
		for $code (@codes) {
			for $class (@classes) {
				# some NAS benchmarks require power of 2 procs and some
				# require perfect square number of procs
				if ($code =~ /sp|bt/) {
					# perfect square codes
					next unless perfect_square($nprocs);
					print OUT "$code\t$class\t$nprocs\n";
				}
				else {
					# power of two codes
					next unless power_of_two($nprocs);
					print OUT "$code\t$class\t$nprocs\n";
				}
			}
		}
	}
}

close(OUT);
