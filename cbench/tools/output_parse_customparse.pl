#!/usr/bin/perl
# vim: syntax=perl tabstop=4
###############################################################################
#    Copyright (2005) Sandia Corporation.  Under the terms of Contract
#    DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
#    certain rights in this software
#
#    This file is part of Cbench.
#
#    Cbench is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    any later version.
#
#    Cbench is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Cbench; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
###############################################################################

# Utility to use just the custom parse filters to parse through an output file

# need to know where everything cbench lives!
use lib ($ENV{CBENCHOME} ? $ENV{CBENCHOME} : "$ENV{HOME}\/cbench");
$BENCH_HOME = $ENV{CBENCHOME} ? $ENV{CBENCHOME} :
	"$ENV{HOME}\/cbench";
require "cbench.pl";

# add Cbench perl library to the Perl search path
use lib ($ENV{CBENCHOME} ? "$ENV{CBENCHOME}\/perllib" :
	"$ENV{HOME}\/cbench\/perllib");

# enable/disable color support appropriately
detect_color_support();

use Getopt::Long;
use Term::ANSIColor qw(:constants color);
$Term::ANSIColor::AUTORESET = 1;

my $nummatches = 1;

GetOptions(
    'sourceonly'  => \$sourceonly,
    'destonly'  => \$destonly,
    'sourcedestonly'  => \$sourcedestonly,
    'threshold=i'  => \$threshold,
	'diag'  => \$diag,
	'nummatches=i'  => \$nummatches,
	'allmatches'  => \$allmatches,
);

my @diag_array = ();
if ($diag) {
	$allmatches = 1;
	$diag_opts = " --sourceonly" if $sourceonly;
	$diag_opts = " --destonly" if $destonly;
	$diag_opts = " --sourcedestonly" if $sourcedestonly;
	$diag_opts .= " --threshold=$threshold" if $threshold;
}

# Load all theh parse_filter modules which define the %parse_filters
# hash, i.e. the custom parse filters feature. We'll need them for parsing
# the output files if the --customparse flag is given
my %parse_filters;
load_parse_filter_modules(\%parse_filters);

# read in the file
my $file = $ARGV[0];

open(IN,"<$file") or exit 1;
my @bufraw = (<IN>);
close(IN);

# we will need a data structure to keep track of hits to
# the custom parse filters, so well build a hash with
# the same keys as the %parse_filters array (from
# cluster.def)
my %filterhits = ();
foreach my $k (keys %parse_filters) {
	$filterhits{$k} = 0;
}				

foreach my $l (@bufraw) {
	# skip the "whitespace" output generated by the 
	# 'stress' benchmark since it can generate a TON of
	# useless output
	($l =~ /\.\.\.\.\.\.\.\.\+$/) and next;
	foreach my $filter (keys %parse_filters) {
		my @capture = undef;
		if ((@capture) = $l =~ /$filter/) {
			# currently, we only print out any information
			# about a custom parse filter hit on the 
			# first hit
			(($filterhits{$filter} >= $nummatches) and next) unless $allmatches;
			
			# need to assign a scalar variable for each
			# capture variable
			foreach my $n (0..$#capture) {
				#print "$n = $capture[$n]\n";
				my $t = $n + 1;
				${"var\_$t"} = $capture[$n];
			}

			# now replace any capture variables in the
			# the parse filter output string
			my $temp = $parse_filters{$filter};
			$temp =~ s/\$(\w+)/${"var_$1"}/ge;
			
			# hold data to print for diag_output_parse.pl
			if ($diag) {
				push @diag_array, "**PARSEMATCH**($file) =>  $temp\n"
			} else {
			print BOLD YELLOW "**PARSEMATCH**";
			print RESET "(";
						print GREEN, "$file";
						print RESET ")";
						print BOLD WHITE, "=> ";
						print BOLD CYAN, "$temp";
						print RESET "\n";
			}
						$filterhits{$filter}++;
		}
	}
}

if ($diag) {
	open (DIAG_OUT, "|$BENCH_HOME/tools/diag_output_parse.pl $diag_opts");
	print DIAG_OUT @diag_array;
	close (DIAG_OUT);
}

sub usage {
    print   "USAGE: $0 FILE\n";
    print   "Cbench script to analyze a job output file (e.g. stdout file) using the".
	        "custom parse filters.".
            "   --diag               Run output ehrough further diagnosis\n".
            "   	--threshold <num>    Print when threshold is reached (default 1)\n".
            "   	--sourcedestonly     Print source and dest data only\n".
            "   	--sourceonly         Print source data. only\n".
            "   	--destonly           Print destination data. only\n".
            "   --nummatches <num>   Match up to <num> occurrences of a given parse filter\n".
            "   --allmatches         Match all occurrences of a given parse filter\n";
}
